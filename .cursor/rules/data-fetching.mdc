---
description:
globs:
alwaysApply: true
---
# Data Fetching & State Management

Matters Web uses Apollo Client for GraphQL data fetching and state management.

## GraphQL Structure

- `src/components/GQL/queries`: Contains reusable GraphQL queries
- `src/components/GQL/mutations`: Contains reusable GraphQL mutations
- Component-specific GraphQL operations are typically defined in a `gql.ts` file within each component directory

## Apollo Client

The Apollo Client is configured in the app entry point (`src/common/utils/apollo.ts`) and provides:
- Cached data management
- Error handling
- Authentication management

## Cache Management

Apollo Client provides powerful caching capabilities that help optimize performance and user experience. There are 3 main approaches to update the cache:

- **Automatic Updates**: Apollo automatically updates the cache for entities with matching IDs
- **Refetching Queries**: Force refetch queries after mutations to ensure fresh data
- **Manual Updates**: Directly modify the cache for complex scenarios

### 1. Automatic Updates

```tsx
const TOGGLE_PIN = gql`
  mutation TogglePin($id: ID!, $pinned: Boolean!) {
    editArticle(input: { id: $id, pinned: $pinned }) {
      id
      pinned
    }
  }
`
```

**When to use:** For simple mutations that modify a single entity's properties.

**Key point:** Make sure your mutation returns the same fields that your queries request, including the `id` field.

### 2. Refetching Queries

```tsx
// Update cache by evicting the old data and force to refetch the related queries
const [updateArticle] = useMutation(UPDATE_ARTICLE_MUTATION, {
  update(cache, { data: { updateArticle } }) {
    cache.evict({ id: cache.identify(article) })
    cache.gc()
  },
  onQueryUpdated(observableQuery) {
    return observableQuery.refetch()
  },
})

// Or without mutation
client.refetchQueries({
  updateCache: (cache) => {
    cache.evict({ id: cache.identify(article) })
    cache.gc()
  },
  include: ['ArticleDetailPublic'], // Optional: specify queries to refetch
})

// Update cache by refetching the given queries
// Note: We prefer `update` & `onQueryUpdated` over `refetchQueries`
// as we don't need to know which queries are affected by the mutation
const [updateArticle] = useMutation(UPDATE_ARTICLE_MUTATION, {
  refetchQueries: [
    'ArticleDetailPublic', // By query name
    { query: ARTICLE_DETAIL_PUBLIC, variables: { shortHash } }, // With variables
  ],
})
```

**When to use:** When mutations affect multiple entities or when you need to ensure the UI reflects the latest server state. Useful after complex operations like publishing content or when automatic updates aren't sufficient. This approach ensures all related pages and components are updated with the latest data.

### 3. Manual Updates

```tsx
// use readQuery and writeQuery
const [addComment] = useMutation(ADD_COMMENT, {
  update(cache, { data: { addComment } }) {
    const { article } = cache.readQuery({
      query: GET_ARTICLE,
      variables: { id: articleId },
    })

    cache.writeQuery({
      query: GET_ARTICLE,
      variables: { id: articleId },
      data: {
        article: {
          ...article,
          comments: [...article.comments, addComment],
        },
      },
    })
  },
})

// use cache.modify
const [deleteComment] = useMutation(DELETE_COMMENT, {
  update(cache, { data: { deleteComment } }) {
    cache.modify({
      id: cache.identify({ __typename: 'Article', id: articleId }),
      fields: {
        comments(existingComments = [], { readField }) {
          return existingComments.filter(
            (commentRef) => readField('id', commentRef) !== deleteComment.id
          )
        },
      },
    })
  },
})
```

**When to use:** For operations that modify relationships between entities, when invalidating stale data. This approach is useful for updating the current page's data without requiring a full refetch.

### Common Patterns

- **Optimistic Updates**: Immediately update UI before server responds
- **Cache Normalization**: Apollo stores entities by ID to avoid duplication
- **Pagination**: Use field policies with `keyArgs` for paginated data
- **Type Policies**: Configure how specific types are stored and merged

For more details, see the [Mutations](https://www.apollographql.com/docs/react/data/mutations), [Refetching queries](https://www.apollographql.com/docs/react/data/refetching), and [Caching in Apollo Client](https://www.apollographql.com/docs/react/caching/overview).


## Example Components

- [src/components/GQL](mdc:src/components/GQL): Core GraphQL components
- [src/components/ClientUpdater](mdc:src/components/ClientUpdater): Components for client-side cache updates
